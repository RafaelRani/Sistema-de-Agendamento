// jQuery Mask Plugin v1.14.16
// github.com/igorescobar/jQuery-Mask-Plugin
var $jscomp = $jscomp || {}; $jscomp.scope = {}; $jscomp.findInternal = function (a, n, f) { a instanceof String && (a = String(a)); for (let p = a.length, k = 0; k < p; k++) { const b = a[k]; if (n.call(f, b, k, a)) return { i: k, v: b }; } return { i: -1, v: void 0 }; }; $jscomp.ASSUME_ES5 = !1; $jscomp.ASSUME_NO_NATIVE_MAP = !1; $jscomp.ASSUME_NO_NATIVE_SET = !1; $jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ? Object.defineProperty : function (a, n, f) { a != Array.prototype && a != Object.prototype && (a[n] = f.value); }; $jscomp.getGlobal = function (a) { return typeof window != 'undefined' && window === a ? a : typeof global != 'undefined' && global != null ? global : a; }; $jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function (a, n, f, p) { if (n) { f = $jscomp.global; a = a.split('.'); for (p = 0; p < a.length - 1; p++) { const k = a[p]; k in f || (f[k] = {}); f = f[k]; }a = a[a.length - 1]; p = f[a]; n = n(p); n != p && n != null && $jscomp.defineProperty(f, a, { configurable: !0, writable: !0, value: n }); } }; $jscomp.polyfill('Array.prototype.find', (a) => a || function (a, f) { return $jscomp.findInternal(this, a, f).v; }, 'es6', 'es3');
(function (a, n, f) { typeof define === 'function' && define.amd ? define(['jquery'], a) : typeof exports === 'object' && typeof Meteor === 'undefined' ? module.exports = a(require('jquery')) : a(n || f); }((a) => {
  const n = function (b, d, e) {
    var c = {
      invalid: [],
      getCaret() { try { let a = 0; const r = b.get(0); const h = document.selection; const d = r.selectionStart; if (h && navigator.appVersion.indexOf('MSIE 10') === -1) { const e = h.createRange(); e.moveStart('character', -c.val().length); a = e.text.length; } else if (d || d === '0')a = d; return a; } catch (C) {} },
      setCaret(a) {
        try {
          if (b.is(':focus')) {
            const c = b.get(0); if (c.setSelectionRange)c.setSelectionRange(a, a); else { const g = c.createTextRange(); g.collapse(!0); g.moveEnd('character', a); g.moveStart('character', a); g.select(); }
          }
        } catch (B) {}
      },
      events() {
        b.on('keydown.mask', (a) => { b.data('mask-keycode', a.keyCode || a.which); b.data('mask-previus-value', b.val()); b.data('mask-previus-caret-pos', c.getCaret()); c.maskDigitPosMapOld = c.maskDigitPosMap; }).on(a.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', c.behaviour).on('paste.mask drop.mask', () => {
          setTimeout(
            () => { b.keydown().keyup(); },
            100,
          );
        }).on('change.mask', () => { b.data('changed', !0); })
          .on('blur.mask', () => { f === c.val() || b.data('changed') || b.trigger('change'); b.data('changed', !1); })
          .on('blur.mask', () => { f = c.val(); })
          .on('focus.mask', (b) => { !0 === e.selectOnFocus && a(b.target).select(); })
          .on('focusout.mask', () => { e.clearIfNotMatch && !k.test(c.val()) && c.val(''); });
      },
      getRegexMask() {
        for (var a = [], b, c, e, t, f = 0; f < d.length; f++) {
          (b = l.translation[d.charAt(f)]) ? (c = b.pattern.toString().replace(/.{1}$|^.{1}/g, ''), e = b.optional,
          (b = b.recursive) ? (a.push(d.charAt(f)), t = { digit: d.charAt(f), pattern: c }) : a.push(e || b ? `${c}?` : c)) : a.push(d.charAt(f).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
        }a = a.join(''); t && (a = a.replace(new RegExp(`(${t.digit}(.*${t.digit})?)`), '($1)?').replace(new RegExp(t.digit, 'g'), t.pattern)); return new RegExp(a);
      },
      destroyEvents() { b.off('input keydown keyup paste drop blur focusout '.split(' ').join('.mask ')); },
      val(a) {
        let c = b.is('input') ? 'val' : 'text'; if (arguments.length > 0) {
          if (b[c]() !== a)b[c](a);
          c = b;
        } else c = b[c](); return c;
      },
      calculateCaretPosition(a) { let d = c.getMasked(); let h = c.getCaret(); if (a !== d) { let e = b.data('mask-previus-caret-pos') || 0; d = d.length; const g = a.length; let f = a = 0; let l = 0; let k = 0; let m; for (m = h; m < d && c.maskDigitPosMap[m]; m++)f++; for (m = h - 1; m >= 0 && c.maskDigitPosMap[m]; m--)a++; for (m = h - 1; m >= 0; m--)c.maskDigitPosMap[m] && l++; for (m = e - 1; m >= 0; m--)c.maskDigitPosMapOld[m] && k++; h > g ? h = 10 * d : e >= h && e !== g ? c.maskDigitPosMapOld[h] || (e = h, h = h - (k - l) - a, c.maskDigitPosMap[h] && (h = e)) : h > e && (h = h + (l - k) + f); } return h; },
      behaviour(d) {
        d = d || window.event; c.invalid = []; let e = b.data('mask-keycode'); if (a.inArray(e, l.byPassKeys) === -1) { e = c.getMasked(); const h = c.getCaret(); const g = b.data('mask-previus-value') || ''; setTimeout(() => { c.setCaret(c.calculateCaretPosition(g)); }, a.jMaskGlobals.keyStrokeCompensation); c.val(e); c.setCaret(h); return c.callbacks(d); }
      },
      getMasked(a, b) {
        let h = []; const f = void 0 === b ? c.val() : `${b}`; let g = 0; const k = d.length; let n = 0; const p = f.length; let m = 1; let r = 'push'; let u = -1; let w = 0; b = []; if (e.reverse) {
          r = 'unshift'; m = -1; var x = 0; g = k - 1; n = p - 1; var A = function () {
            return g
> -1 && n > -1;
          };
        } else x = k - 1, A = function () { return g < k && n < p; }; for (var z; A();) { const y = d.charAt(g); const v = f.charAt(n); const q = l.translation[y]; if (q)v.match(q.pattern) ? (h[r](v), q.recursive && (u === -1 ? u = g : g === x && g !== u && (g = u - m), x === u && (g -= m)), g += m) : v === z ? (w--, z = void 0) : q.optional ? (g += m, n -= m) : q.fallback ? (h[r](q.fallback), g += m, n -= m) : c.invalid.push({ p: n, v, e: q.pattern }), n += m; else { if (!a)h[r](y); v === y ? (b.push(n), n += m) : (z = y, b.push(n + w), w++); g += m; } }a = d.charAt(x); k !== p + 1 || l.translation[a] || h.push(a); h = h.join(''); c.mapMaskdigitPositions(
          h,
          b,
          p,
        ); return h;
      },
      mapMaskdigitPositions(a, b, d) { a = e.reverse ? a.length - d : 0; c.maskDigitPosMap = {}; for (d = 0; d < b.length; d++)c.maskDigitPosMap[b[d] + a] = 1; },
      callbacks(a) { const g = c.val(); const h = g !== f; const k = [g, a, b, e]; const l = function (a, b, c) { typeof e[a] === 'function' && b && e[a].apply(this, c); }; l('onChange', !0 === h, k); l('onKeyPress', !0 === h, k); l('onComplete', g.length === d.length, k); l('onInvalid', c.invalid.length > 0, [g, a, b, c.invalid, e]); },
    }; b = a(b); var l = this; var f = c.val(); let k; d = typeof d === 'function' ? d(c.val(), void 0, b, e) : d; l.mask = d; l.options = e; l.remove = function () { const a = c.getCaret(); l.options.placeholder && b.removeAttr('placeholder'); b.data('mask-maxlength') && b.removeAttr('maxlength'); c.destroyEvents(); c.val(l.getCleanVal()); c.setCaret(a); return b; }; l.getCleanVal = function () { return c.getMasked(!0); }; l.getMaskedVal = function (a) { return c.getMasked(!1, a); }; l.init = function (g) {
      g = g || !1; e = e || {}; l.clearIfNotMatch = a.jMaskGlobals.clearIfNotMatch; l.byPassKeys = a.jMaskGlobals.byPassKeys; l.translation = a.extend({}, a.jMaskGlobals.translation, e.translation);
      l = a.extend(!0, {}, l, e); k = c.getRegexMask(); if (g)c.events(), c.val(c.getMasked()); else { e.placeholder && b.attr('placeholder', e.placeholder); b.data('mask') && b.attr('autocomplete', 'off'); g = 0; for (var f = !0; g < d.length; g++) { const h = l.translation[d.charAt(g)]; if (h && h.recursive) { f = !1; break; } }f && b.attr('maxlength', d.length).data('mask-maxlength', !0); c.destroyEvents(); c.events(); g = c.getCaret(); c.val(c.getMasked()); c.setCaret(g); }
    }; l.init(!b.is('input'));
  }; a.maskWatchers = {}; const f = function () {
    const b = a(this); const d = {}; const e = b.attr('data-mask');
    b.attr('data-mask-reverse') && (d.reverse = !0); b.attr('data-mask-clearifnotmatch') && (d.clearIfNotMatch = !0); b.attr('data-mask-selectonfocus') === 'true' && (d.selectOnFocus = !0); if (p(b, e, d)) return b.data('mask', new n(this, e, d));
  }; var p = function (b, d, e) { e = e || {}; const c = a(b).data('mask'); const f = JSON.stringify; b = a(b).val() || a(b).text(); try { return typeof d === 'function' && (d = d(b)), typeof c !== 'object' || f(c.options) !== f(e) || c.mask !== d; } catch (w) {} }; let k = function (a) {
    const b = document.createElement('div'); a = `on${a}`; let e = a in b; e || (b.setAttribute(
      a,
      'return;',
    ), e = typeof b[a] === 'function'); return e;
  }; a.fn.mask = function (b, d) { d = d || {}; const e = this.selector; let c = a.jMaskGlobals; const f = c.watchInterval; c = d.watchInputs || c.watchInputs; const k = function () { if (p(this, b, d)) return a(this).data('mask', new n(this, b, d)); }; a(this).each(k); e && e !== '' && c && (clearInterval(a.maskWatchers[e]), a.maskWatchers[e] = setInterval(() => { a(document).find(e).each(k); }, f)); return this; }; a.fn.masked = function (a) { return this.data('mask').getMaskedVal(a); }; a.fn.unmask = function () {
    clearInterval(a.maskWatchers[this.selector]);
    delete a.maskWatchers[this.selector]; return this.each(function () { const b = a(this).data('mask'); b && b.remove().removeData('mask'); });
  }; a.fn.cleanVal = function () { return this.data('mask').getCleanVal(); }; a.applyDataMask = function (b) { b = b || a.jMaskGlobals.maskElements; (b instanceof a ? b : a(b)).filter(a.jMaskGlobals.dataMaskAttr).each(f); }; k = {
    maskElements: 'input,td,span,div',
    dataMaskAttr: '*[data-mask]',
    dataMask: !0,
    watchInterval: 300,
    watchInputs: !0,
    keyStrokeCompensation: 10,
    useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent)
&& k('input'),
    watchDataMask: !1,
    byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
    translation: {
      0: { pattern: /\d/ }, 9: { pattern: /\d/, optional: !0 }, '#': { pattern: /\d/, recursive: !0 }, A: { pattern: /[a-zA-Z0-9]/ }, S: { pattern: /[a-zA-Z]/ },
    },
  }; a.jMaskGlobals = a.jMaskGlobals || {}; k = a.jMaskGlobals = a.extend(!0, {}, k, a.jMaskGlobals); k.dataMask && a.applyDataMask(); setInterval(() => { a.jMaskGlobals.watchDataMask && a.applyDataMask(); }, k.watchInterval);
}, window.jQuery, window.Zepto));
